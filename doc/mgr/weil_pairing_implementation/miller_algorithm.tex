\section{Algorytm Millera}

Opiszemy teraz algorytm Millera,
obliczający wartości iloczynu Weila,
poprzez podanie jego pseudokodu.

Aby nie doszło do nieporozumień przy odczytywaniu
prezentowanego pseudokodu,
musimy najpierw poczynić szereg ustaleń.

\begin{remark}
Przyjmujemy, że przy prezentowaniu pseudokodu w niniejszej pracy
obowiązują następujące konwencje:
\begin{itemize}
\item pseudokod będziemy zapisywać w formie podobnej do tej
stosowanej w książce \ref{clrs};
\item operacje arytmetyczne na liczbach całkowitych
uznajemy za elementarne
i oznaczamy je symbolami $+$, $-$, $\cdot$, $\kw{div}$, $\kw{mod}$;
\item porównania liczb całkowitych ($=$, $\neq$, $<$, $\leq$, $>$, $\geq$)
uznajemy za elementarne;
\item operacje arytmetyczne na elementach ciał skończonych
uznajemy za elementarne
i oznaczamy je symbolami $+$, $-$, $\cdot$, $/$;
\item porównania elementów ciał skończonych ($=$, $\neq$)
uznajemy za elementarne;
\item porównania punktów na krzywej eliptycznej ($=$, $\neq$)
uznajemy za elementarne;
\item ustalamy, że notacja $p[o]$ oznacza odczytanie cechy $p$ obiektu $o$,
w szczególności:
\begin{itemize}
\item $a[l]$ $b[l]$ i $c[l]$ oznaczają odpowiednio
współczynnik stojący przy zmiennej $x$ w linii $l$,
współczynnik stojący przy zmiennej $y$ w linii $l$
i wyraz wolny linii $l$;
\item $A[E]$, $B[E]$, $\id{field}[E]$, $\id{identity}[E]$
oznaczają odpowiednio
parametry krzywej $E$, ciało, nad którym krzywa $E$ jest zdefiniowana
i punkt w nieskończoności krzywej $E$;
\item $x[P]$ i $y[P]$ oznaczają współrzędne skończonego punktu $P$ krzywej;
\end{itemize}
\item zakładamy, że dysponujemy następującymi procedurami:
\begin{itemize}
\item $\proc{Random-Integer}(n)$, 
która wybiera losowo z rozkładem jednostajnym
liczbę całkowitą $a$ taką, że $0 \leq a < n$;
\item $\proc{Random-Finite-Field-Element}(\K)$,
która wybiera losowo z rozkładem jednostajnym
element ciała skończonego $\K$;
\item $\proc{Finite-Field-Element-Square-Root}(\K, a)$,
która oblicza
dowolny pierwiastek kwadratowy elementu $a \in \K$
lub przekazuje stałą $\const{error}$, jeśli taki pierwiastek nie istnieje;
\item $\proc{Curve-Finite-Point}(E, a, b)$,
która konstruuje
punkt skończony krzywej $E$ o współrzędnych $a$ i $b$;
\item $\proc{Curve-Point-Conjugate}(E, P)$,
która oblicza
punkt sprzężony do punktu $P \in E$;
\item $\proc{Line-On-Curve}(E, a, b, c)$,
która konstruuje
linię o na krzywej $E$ współczynnikach $a$, $b$ i $c$.
\end{itemize}
\end{itemize}
\end{remark}

Ponieważ wybraliśmy bardzo ubogi zestaw operacji elementarnych,
przed opisem procedur związanych bezpośrednio z algorytmem Millera
musimy w postaci pseudokodu przedstawić
ogólne algorytmy związane z krzywymi eliptycznymi.
Część z nich to ujęte w postaci pseudokodu
wzory wyprowadzone wcześniej w pracy.

Rozpoczniemy od procedury obliczającej
wartość linii w punkcie krzywej eliptycznej.
Jest ona trywialna, ale nie uznaliśmy jej za operację elementarną,
dlatego wypada ją zdefiniować.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$,
linia $l$ na krzywej $E$ oraz punkt skończony $P \in E$.
Następująca procedura
na podstawie wartości $E$, $l$ i $P$
oblicza
wartość $l(P)$:

\begin{codebox}
\Procname{$\proc{Line-Value-At-Curve-Finite-Point}(E, l, P)$}
\li
    \Assert $A \neq \id{identity}[E]$
\li
    \Return $a[l]\cdot x[P] + b[l]\cdot y[P] + c[l]$
\end{codebox}
\end{algorithm}

Podamy teraz procedury wyznaczające linie przechodzące przez zadane punkty.
Najpierw rozważymy przypadki szczególne,
dla których wyznaczyliśmy wcześniej odpowiednie wzory.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$
oraz punkt skończony $P \in E$.
Następująca procedura
na podstawie wartości $E$ i $P$
oblicza
linię pionową przechodzącą przez punkt $P$:

\begin{codebox}
\Procname{$\proc{Vertical-Line-Through-Finite-Point}(E, A)$}
\li
    \Assert $A \neq \id{identity}[E]$
\li
    $a \gets x[A]$
\li
    \Return $\proc{Line-On-Curve}(E, 1, 0, -a)$
\end{codebox}
\end{algorithm}

\begin{algorithm}
Dana jest krzywa eliptyczna $E$
oraz dwa różne punkty skończone $A, B \in E$.
Następująca procedura
na podstawie wartości $E$, $P$ i $Q$
oblicza
linię przechodzącą przez punkty $P$ i $Q$:

\begin{codebox}
\Procname{$\proc{Line-Through-Different-Curve-Finite-Points}(E, P, Q)$}
\li
    \Assert $P \neq \id{identity}[E] \kw{ and } P \neq \id{identity}[E]$
\li
    \Assert $P \neq Q$
\li
    $a \gets x[P]$
\li
    $b \gets y[P]$
\li
    $c \gets x[Q]$
\li
    $d \gets y[Q]$
\li
    \If $a = c$
\li
        \Then
            \Return $\proc{Line-On-Curve}(E, 1, 0, -a)$
\li
        \Else
            $\lambda \gets (d-b)/(c-a)$
\li
            \Return $\proc{Line-On-Curve}(E, \lambda, -1, -(\lambda\cdot a - b))$
        \End
\end{codebox}
\end{algorithm}

\begin{algorithm}
Dana jest krzywa eliptyczna $E$
oraz punkt skończony $P \in E$.
Następująca procdeura
na podstawie wartości $E$ i $P$
oblicza
linię styczną do krzywej $E$ przechodzącą przez punkt $P$:

\begin{codebox}
\Procname{$\proc{Tangent-Line-Through-Curve-Finite-Point}(E, P)$}
\li
    \Assert $P \neq \id{identity}[E]$
\li
    $a \gets x[P]$
\li
    $b \gets y[P]$
\li
    \If $b = 0$
\li
        \Then
            \Return $\proc{Line-On-Curve}(E, 1, 0, -a)$
\li
        \Else
            $\lambda \gets (3\cdot a \cdot a + A[E])/(2\cdot b)$
\li
            \Return $\proc{Line-On-Curve}(E, \lambda, -1, -(\lambda\cdot a - b))$
        \End
\end{codebox}
\end{algorithm}

Podane procedury zbierzemy teraz w jedną całość --
procedurę, która wyznacza linię przechodzącą przez dowolne dwa punkty krzywej.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$
oraz punkty $P, Q \in E$,
z których co najmniej jeden jest skończony.
Następująca procedura
na podstawie wartości $E$, $P$ i $Q$
oblicza
linię przechodzącą przez punkty $P$ i $Q$
(lub styczną do krzywej w punkcie $P$, gdy $P = Q$):

\begin{codebox}
\Procname{$\proc{Line-Through-Curve-Points}(E, P, Q)$}
\li
    \Assert $P \neq \id{identity}[E] \kw{ or } Q \neq \id{identity}[E]$
\li
    \If $P = \id{identity}[E]$
\li
        \Then
            \Return $\proc{Vertical-Line-Through-Curve-Finite-Point}(E, Q)$
        \End
\li
    \If $Q = \id{identity}[E]$
\li
        \Then
            \Return $\proc{Vertical-Line-Trough-Curve-Finite-Point}(E, P)$
        \End
\li
    \If $P \neq Q$
\li
        \Then
            \Return $\proc{Line-Through-Different-Curve-Finite-Points}(E, P, Q)$
\li
        \Else
            \Return $\proc{Tangent-Line-Through-Curve-Finite-Point}(E, P)$
        \End
\end{codebox}
\end{algorithm}

Kolejną ogólną procedurą jest dodawanie dwóch punktów krzywej,
a w następstwie mnożenie punktu przez liczbę naturalną.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$
oraz punkty $P, Q \in E$.
Następująca procedura
na podstawie wartości $E$, $P$ i $Q$
oblicza
punkt $P + Q$:

\begin{codebox}
\Procname{$\proc{Add-Curve-Points}(E, P, Q)$}
\li
    \If $P = \id{identity}[E]$
\li
        \Then
            \Return $Q$
        \End
\li
    \If $Q = \id{identity}[E]$
\li
        \Then
            \Return $P$
        \End
\li
    \If $P = \proc{Curve-Point-Conjugate}(E, Q)$
\li
        \Then
            \Return $\id{identity}[E]$
        \End
\li
    $a \gets x[P]$
\li
    $b \gets y[P]$
\li
    $c \gets x[Q]$
\li
    $d \gets y[Q]$
\li
    \If $P \neq Q$
\li
        \Then
            $\lambda \gets (d - b)/(c - a)$
\li
        \Else
            $\lambda \gets (3\cdot a\cdot a + A[E])/(2\cdot b)$
        \End
\li
    $e \gets \lambda\cdot\lambda - a - c$
\li
    $f \gets -\lambda\cdot(e - a) - b$
\li
    \Return $\proc{Curve-Finite-Point}(e, f)$
\end{codebox}
\end{algorithm}

\begin{algorithm}
Dana jest krzywa eliptyczna $E$,
punkt $P \in E$ oraz liczba całkowita $n$.
Następująca procedura
na podstawie wartości $E$, $P$ i $n$
oblicza
punkt $nP$:

\begin{codebox}
\Procname{$\proc{Multiply-Curve-Point}(E, P, n)$}
\li
    \If $P = \id{identity}[E]$
\li
        \Then
            \Return $\id{identity}[E]$
        \End
\li
    \If $y[P] = 0$
\li
        \Then
            \If $n \kw{ mod } 2 = 0$
\li
                \Then
                    \Return $\id{identity}[E]$
\li
                \Else
                    \Return $P$
                \End
        \End
\li
    \If $n = 0$
\li
        \Then
            \Return $\id{identity}[E]$
        \End
\li
    \If $n > 0$
\li
        \Then
            $m \gets n$
\li
        \Else
            $m \gets -n$
        \End
\li
    $R \gets \id{identity}[E]$
\li
    \While $m > 0$
\li
        \Do
            \If $m \kw{ mod } 2 = 1$
\li
                \Then
                    $R \gets \proc{Add-Curve-Points}(R, P)$
                \End
\li
            $P \gets \proc{Add-Curve-Points}(P, P)$
\li
            $m \gets m \kw{ div } 2$
        \End
\li
    \If $n > 0$
\li
        \Then
            \Return $R$
\li
        \Else
            \Return $\proc{Curve-Point-Conjugate}(E, R)$
        \End
\end{codebox}
\end{algorithm}

Ostatnią ogólną procedurą jest losowanie punktu na krzywej eliptycznej.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$ nad ciałem skończonym.
Następująca procedura
na podstawie wartości $E$
wybiera losowo z rozkładem jednostajnym
punkt krzywej $E$:

\begin{codebox}
\Procname{$\proc{Random-Curve-Point}(E)$}
\li
    $f \gets \id{field}[E]$
\li
    $c \gets \id{cardinality}[f]$
\li
    \While $\const{true}$
\li
        \Do
            $n \gets \proc{Random-Integer}(c + 1)$
\li
            \If $n = c$
\li
                \Then
                    \If $\proc{Random-Integer}(2) = 0$
\li
                        \Then
                            \Return $\id{identity}[E]$
                        \End
\li
                \Else
                    $a \gets \proc{Random-Finite-Field-Element}(f)$
\li
                    \If $a\cdot a\cdot a + A[E]\cdot a + B[E] = 0$
\li
                        \Then
                            \If $\proc{Random-Integer}(2) = 0$
\li
                                \Then
                                    \Return $\proc{Curve-Finite-Point}(a, 0)$
                                \End
\li
                        \Else
                            $b \gets \proc{Finite-Field-Element-Square-Root}(f, a)$
\li
                            \If $b \neq \const{error}$
\li
                                \Then
                                    \If $\proc{Random-Integer}(2) = 0$
\li
                                        \Then
                                            \Return $\proc{Curve-Finite-Point}(a, b)$
\li
                                        \Else
                                            \Return $\proc{Curve-Finite-Point}(a, -b)$
                                        \End
                                \End
                        \End
                \End
        \End
\end{codebox}
\end{algorithm}

Możemy teraz przejść do opisania algorytmu Millera.


Następująca procedura jest przełożeniem lematu \ref{dupa} na pseudokod.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$ oraz punkt skończony $A \in E$.
Następująca procedura
na podstawie wartości $A$, $K = kP$, $L = lP$, $u = f_k(A)$ i $v = f_l(A)$
przekazuje jako wynik
wartość $f_{k+l}(P)$:

\begin{codebox}
\Procname{$\proc{Combine-Function-Values}(E, A, K, L, u, v)$}
\li
    $g \gets \proc{Line-Through-Points}(E, K, L)$
\li
    $h \gets \proc{Vertical-Line-Through-Point}(\proc{Add-Points}(E, K, L))$
\li
    $s \gets \proc{Line-Value-At-Point}(E, g, A)$
\li
    $t \gets \proc{Line-Value-At-Point}(E, h, A)$
\li
    \If $s = 0$ \kw{or} $t = 0$
\li
        \Then \Return $\const{error}$
    \End
\li
    \Return $u \cdot v \cdot (s / t)$
\end{codebox}
\end{algorithm}

Zastosujemy teraz schemat ,,podwajaj-i-dodawaj'' do procedury \ref{dupa},
aby otrzymać procedurę obliczającą wartość $f_n(A)$.

\begin{algorithm}
Dana jest krzywa eliptyczna $E$,
punkt skończony $A \in E$ oraz liczba naturalna $n$.
Następująca procedura
na podstawie wartości $E$, $A$, $P$, $R$ i $n$
przekazuje jako wynik
wartość $f_n(A)$:

\begin{codebox}
\Procname{$\proc{Compute-Function-Value}(E, A, P, R, n)$}
\li
    $g \gets \proc{Line-Through-Points}(E, P, R)$
\li
    $h \gets \proc{Vertical-Line-Through-Point}(E, \proc{Add-Points}(E, P, R))$
\li
    $U \gets \id{identity}[E]$
\li
    $V \gets P$
\li
    $u \gets 1$
\li
    $v \gets \proc{Line-Value-At-Point}(E, h, A) /
            \proc{Line-Value-At-Point}(E, g, A)$
\li
    \While $n > 0$
\li
        \Do
            \If $v = \const{error}$
\li
                \Then
                    \Return $\const{error}$
                \End
\li
            \If $n \kw{ mod } 2 = 1$
\li
                \Then
                    $u \gets \proc{Combine-Function-Values}(E, A, U, V, u, v)$
\li
                    $U \gets \proc{Add-Points}(U, V)$
\li
                    \If $u = \const{error}$
\li
                        \Then
                            \Return $\const{error}$
                        \End
                \End
\li
            $v \gets \proc{Combine-Function-Values}(E, A, V, V, v, v)$
\li
            $V \gets \proc{Add-Points}(E, V, V)$
\li
            $n \gets n \kw{ div } 2$
        \End
\li
    \Return $u$
\end{codebox}
\end{algorithm}

\begin{algorithm}
Dana jest krzywa eliptyczna $E$ oraz punkty $P,Q \in E[n]$.
Następująca procedura
na podstawie wartości $E$, $P$, $Q$ i $n$
oblicza wartość
$w(P, Q)$:

\begin{codebox}
\Procname{$\proc{Weil-Pairing}(P, Q, n)$}
\li
    \While $\const{true}$
\li
        \Do
            $R \gets \proc{Random-Curve-Point(E)}$
\li
            $S \gets \proc{Random-Curve-Point(E)}$
\li
            $P' \gets \proc{Add-Curve-Points}(E, P, R)$
\li
            $Q' \gets \proc{Add-Curve-Points}(E, Q, S)$
\li
            $a \gets \proc{Compute-Function-Value}(E, Q', P, P', n)$
\li
            $b \gets \proc{Compute-Function-Value}(E, Q, P, P', n)$
\li
            $c \gets \proc{Compute-Function-Value}(E, P', Q, Q', n)$
\li
            $d \gets \proc{Compute-Function-Value}(E, P, Q, Q', n)$
\li
            \If $a \neq \const{error} \kw{ and } b \neq \const{error} \kw{ and }
                    c \neq \const{error} \kw{ and } d \neq \const{error}$
\li
                \Then
                    \Return $(a / b)\cdot(d / c)$
                \End
        \End
\end{codebox}
\end{algorithm}
